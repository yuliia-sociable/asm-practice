section .bss
    ; Буфер для зберігання результату конвертації.
    ; 11 байт достатньо для 32-бітного числа (10 цифр + знак мінуса) + \n
    buffer resb 12

section .text
    global _start

; =============================================================================
; int2str(eax: integer, esi: buffer) -> eax: length
; Конвертує ціле число в рядок.
; Вхід:
;   EAX - число для конвертації (наприклад, 1234567)
;   ESI - вказівник на буфер для запису рядка
; Вихід:
;   EAX - довжина отриманого рядка
; =============================================================================
int2str:
    ; Зберігаємо регістри, які будемо змінювати
    push ebx
    push ecx
    push edx

    mov ebx, 10         ; Встановлюємо дільник 10
    xor ecx, ecx        ; Обнуляємо лічильник символів (ECX буде зберігати довжину)

.conversion_loop:
    xor edx, edx        ; Обнуляємо EDX, оскільки DIV використовує пару EDX:EAX
    div ebx             ; Ділимо EAX на 10. Результат в EAX, залишок в EDX.
    add edx, '0'        ; Перетворюємо залишок (цифру) в ASCII-символ ('0' = 48)
    push edx            ; Зберігаємо символ у стеку (цифри будуть у зворотному порядку)
    inc ecx             ; Збільшуємо лічильник символів
    test eax, eax       ; Перевіряємо, чи EAX не дорівнює нулю
    jnz .conversion_loop ; Якщо не нуль, продовжуємо ділити

    mov eax, ecx        ; Зберігаємо довжину рядка в EAX для повернення

.store_loop:
    pop edx             ; Дістаємо символ зі стека (тепер у правильному порядку)
    mov [esi], dl       ; Записуємо символ у буфер за адресою в ESI
    inc esi             ; Пересуваємо вказівник буфера на наступний байт
    loop .store_loop    ; Повторюємо, поки ECX не стане 0

    ; Додаємо символ нового рядка в кінець для красивого виводу
    mov byte [esi], 0x0a
    inc eax             ; Збільшуємо довжину на 1 (для символу \n)

    ; Відновлюємо збережені регістри
    pop edx
    pop ecx
    pop ebx
    ret                 ; Повертаємося з функції

; =============================================================================
; Головна точка входу в програму
; =============================================================================
_start:
    ; --- Конвертуємо число в рядок ---
    mov eax, 1234567    ; Число для конвертації
    mov esi, buffer     ; Адреса буфера для результату
    call int2str        ; Викликаємо нашу функцію. Довжина повернеться в EAX

    ; --- Виводимо результат на екран ---
    mov edx, eax        ; Довжина рядка (повернулася з int2str)
    mov ecx, buffer     ; Адреса рядка для виводу
    mov ebx, 1          ; Файловий дескриптор: 1 = stdout (стандартний вивід)
    mov eax, 4          ; Системний виклик: 4 = sys_write (записати)
    int 0x80            ; Викликаємо ядро

    ; --- Завершуємо програму ---
    mov eax, 1          ; Системний виклик: 1 = sys_exit (вихід)
    int 0x80            ; Викликаємо ядро